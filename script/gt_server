#!/usr/bin/env ruby
$: << ENV['GTRUBY']

require 'drb'
require 'drb/timeridconv'
require 'gtruby'

##
# The GTServer forwards requests from the GenomeViewer to the
# GenomeTools. Additionally it is responsible for caching
# feature_index, config structures and image maps
#
class GTServer

  ##
  # Creates a GTServer instance
  #
  def initialize
    puts "Initializing GT DRB server"
    STDOUT.flush
    @mutex = Mutex.new
    @feature_indices = Hash.new
    @feature_classes = Hash.new
    @config_objects = Hash.new
    @image_maps = Hash.new
    STDOUT.flush
  end

  def test_call()
    puts "tast_call() called"
    return "test_call() return value"
  end

  ##
  # Validates a gff3 file
  # @param filename Path to a gff3 file
  # @return nil if file is a valid gff3 file, an error describing string otherwise.
  #
  def validate_file(filename)
    begin
      get_feature_index_for_file(filename, :delete_cache => true)
      return nil
    rescue => error
      return error.to_s
    end
  end

  ##
  # Returns sequence region identifiers of a gff3 file
  # @param filename Path to a gff3 file
  # @return The sequence regions contained in filename
  #
  def get_sequence_regions(filename)
    puts "Requested sequence regions for #{filename}"
    STDOUT.flush
    feature_index=get_feature_index_for_file(filename)
    return feature_index.get_seqids
  end

  ##
  # Returns the name of the feature classes contained in a gff3 file
  #
  def get_feature_classes(filename)
    puts "Requested feature classes used in #{filename}"
    STDOUT.flush
    get_feature_index_for_file(filename) # fills feature_classes cache
    return @feature_classes[filename]
  end

  ##
  # Returns a range of a sequence region
  # @param filename Path to a gff3 file
  # @param sequence_region A sequence region identifier
  # @return The range that belongs to the given sequence region
  #
  def get_range_for_sequence_region(filename, sequence_region)
    feature_index=get_feature_index_for_file(filename)
    range = feature_index.get_range_for_seqid(sequence_region)
    return [range.start, range.end]
  end

  ##
  # Creates a new config object 
  # reading the configuration from config/view.lua
  #
  def new_config_object
    c = GT::Config.new
    c.load_file File.expand_path("config/view.lua",
                                 "#{File.dirname(__FILE__)}/..")
    puts "-- new config object (config/view.lua loaded)"
    STDOUT.flush
    return c
  end
 
  ##
  # Returns a config object for a user (based on user_id)
  #
  def config_object_for_user(user_id, options = {})
    @mutex.synchronize do # avoid concurrent accesses

      if @config_objects.has_key?(user_id)
        # If a config_object for the user is in memory return it
        puts "-- using cached config object"
        STDOUT.flush
        config_object = @config_objects[user_id]
        if options[:delete_cache]
          puts "-- deleting cached config object"
          STDOUT.flush
          return @config_objects.delete(user_id)
        else
          return config_object
        end

      else

        # If there is no config_object in memory create one
        config_object = new_config_object
                
        unless options[:delete_cache]
          @config_objects[user_id] = config_object
          puts "-- saved config object in cache"
          STDOUT.flush
        end
        return config_object
      end
    end
  end

  ##
  # Returns a config object with 
  # the default configuration
  #
  def default_config_object
    @config_objects[:default] ||= new_config_object      
  end
  
  ##
  # Does the cache contain a config object for this user_id?
  def cached_config_for?(user_id)
    @config_objects.has_key?(user_id)
  end
  
  ##
  # Returns a Color object
  # Color objects that should be used in Config Objects must be
  # created with this function. They can not be created on the
  # GTServer's client because Color objects can not be moved from
  # a client to this server.
  # @return a Color Object
  #
  def new_color_object
    return GT::Color.malloc
  end

  ##
  # This function ouputs an image as a png stream
  # If the output is written in a file the file is a valid png file.
  # @param filename Path to a gff3 file
  # @param sequence_region A sequence region identifier
  # @param start_pos A start position
  # @param end_pos An end position
  # @param config A Config object created with get_config_object
  # @param width width of the output image
  # @param add_introns switch add_introns genometools functionality
  # @return A png stream
  #
  def get_image_stream(filename, sequence_region, start_pos, end_pos, 
                       config, width, add_introns, map_mode = false)
    puts "Requested image #{map_mode ? 'map' : 'stream'} for:"
    puts "- #{File.basename(filename)}, "
    puts "- seq_id: #{sequence_region},  "
    puts "- range: #{start_pos} - #{end_pos}"
    STDOUT.flush

    feature_index = get_feature_index_for_file(filename, 
                                               :add_introns => add_introns)
    range = feature_index.get_range_for_seqid(sequence_region)
    range.start = start_pos
    range.end = end_pos

    diagram = GT::Diagram.new(feature_index, sequence_region, range, config)
    info = GT::ImageInfo.new
    canvas = GT::Canvas.new(config, width, info)
    diagram.render(canvas)
    
    unless map_mode
      #cache image map
      key = [filename, sequence_region, start_pos, 
             end_pos, config, width, add_introns].hash
      puts "- caching map for key #{key}"
      STDOUT.flush
      @image_maps[key] = info
      
      puts "- streaming..."
      STDOUT.flush
      return canvas.to_stream
    else
      puts "- returning image map..."
      STDOUT.flush
      return info
    end
  end
  
  #
  # returns the image map that was generated with the image
  # (or generate an image and return the image map)
  #
  def get_image_map(*params)
    key = params.hash
    puts "Requested image map for key #{key}:"
    if @image_maps[key]
      puts "- returning image map (cached)..."
      STDOUT.flush
      return @image_maps.delete(key)
    else
      # maybe the server was down?
      puts "- no map in cache: creating one..."
      STDOUT.flush
      params << :map_mode
      return get_image_stream(*params)
    end
  end

  # options:
  # :delete_cache => true : empty the cache for this feature_index [default: false]
  # :add_introns => true  : turns on add_introns feature [default: false]
  def get_feature_index_for_file(filename, options = {})
    @mutex.synchronize do # avoid concurrent @feature_indices accesses

      if @feature_indices.has_key?(filename)
        # If a featureindex for the file is in memory return it
        puts "-- using cached feature index"
        STDOUT.flush
        feature_index = @feature_indices[filename]
        if options[:delete_cache]
          puts "-- deleting cached feature index"
          STDOUT.flush
          return @feature_indices.delete(filename)
        else
          return feature_index
        end

      else

        # If there is no feature index in memory create one
        puts "-- new feature index"
        STDOUT.flush

        in_stream = GT::GFF3InStream.new(filename)

        if options[:add_introns]
          puts "-- adding introns to in_stream"
          STDOUT.flush
          add_introns_stream = GT::AddIntronsStream.new(in_stream)
          in_stream = add_introns_stream
        end

        feature_index = GT::FeatureIndex.new

        feature_stream = GT::FeatureStream.new(in_stream, feature_index)

        loop {break unless feature_stream.next_tree}
        puts "-- populated feature_stream"
        STDOUT.flush

        unless options[:delete_cache]
          @feature_indices[filename] = feature_index
          @feature_classes[filename] = in_stream.get_used_types
          puts "-- saved feature_index in cache"
          STDOUT.flush
        end
        return feature_index
      end
    end
  end
  
  def cached_feature_index_for?(filename)
    @feature_indices.has_key?(filename)
  end
end

DRb.install_id_conv(DRb::TimerIdConv.new) # keep objects on server alive
DRb.start_service("druby://:7777", GTServer.new)
puts "GT DRB server running"
STDOUT.flush
DRb.thread.join
puts "GT DRB server shut down"
STDOUT.flush
