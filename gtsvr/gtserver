#!/usr/bin/env ruby
$: << ENV['GTRUBY']

require 'drb'
require 'gtruby'

##
# The GTServer forwards requests from the GenomeViwer to the
# GenomeTools. Additionally it is responsible for caching
# feature_index structures
#
class GTServer

 ##
 # Creates a GTServer instance
 #
 def initialize()
  @mutex = Mutex.new
  @feature_indices=Hash.new()
 end

 ##
 # Returns sequence regions of a gff3 file
 # @param filename Path to a gff3 file
 # @return The sequence regions contained in filename
 #
 def get_sequence_regions(filename)
  feature_index=get_feature_index_for_file(filename, false)
  return feature_index.get_seqids
 end

 ##
 # Returns a range of a sequence region
 # @param filename Path to a gff3 file
 # @param sequence_region A sequence region identifier
 # @return The range that belongs to the given sequence region
 #
 def get_range_for_sequence_region(filename, sequence_region)
  feature_index=get_feature_index_for_file(filename, false)
  return feature_index.get_range_for_seqid(sequence_region)
 end

 ##
 # Returns a Config object
 # Config objects that should be used with get_image_stream must be
 # created with this function. They can not be created on the
 # GTServer's client because Config objects can not be moved from
 # a client to this server.
 # @return a config Object
 #
 def get_config_object()
  return GT::Config.new
 end

 ##
 # Returns a Color object
 # Color objects that should be used in Config Objects must be
 # created with this function. They can not be created on the
 # GTServer's client because Color objects can not be moved from
 # a client to this server.
 # @return a Color Object
 #
 def getColorObject()
  return GT::Color.malloc
 end

 ##
 # This function ouputs an image as a png stream
 # If the oputupt is written in a file the file is a valid png file.
 # @param filename Path to a gff3 file
 # @param sequence_region A sequence region identifier
 # @param start_pos A start position
 # @param end_pos An end position
 # @param config A Config object created with get_config_object
 # @param width width of the output image
 # @param add_introns switch add_introns genometools functionality
 # @return A png stream
 #
 def get_image_stream (filename, sequence_region, start_pos, end_pos, config, width, add_introns)
  feature_index=get_feature_index_for_file(filename, add_introns)

  range = feature_index.get_range_for_seqid(sequence_region)
  range.start = start_pos
  range.end = end_pos

  diagram = GT::Diagram.new(feature_index, sequence_region, range, config)

  render = GT::Render.new(config)
  return render.to_png_stream(diagram, width)
 end

 ##
 # Validates a gff3 file
 # @param filename Path to a gff3 file
 # @return nil if file is a valid gff3 file, an error describing string otherwise.
 #
 def validateFile(filename)
  begin
   get_feature_index_for_file(filename, false)
   return nil
  rescue => error
   return error.to_s
  end
 end


 private
 def get_feature_index_for_file(filename, add_introns)
  @mutex.synchronize do # avoid concurrent @feature_indices accesses
   if @feature_indices[filename]!=nil then
    # If a featureindex for the file is in memory return it
    return @feature_indices[filename]
   else
    
    #If there is no featureindex in memory create one
    in_stream = GT::GFF3InStream.new(filename)
    
    if add_introns then
     # add_introns_stream = GT::AddIntronsStream.new(in_stream)
     # in_stream = add_introns_stream
    end
    
    feature_index = GT::FeatureIndex.new()
    
    feature_stream = GT::FeatureStream.new(in_stream, feature_index)

    gn = feature_stream.next_tree()
    while (gn) do
     gn = feature_stream.next_tree()
    end

    @feature_indices[filename]=feature_index
    return feature_index
   end
  end
 end

end

puts "Initializing GT DRB server"
DRb.start_service("druby://:7777", GTServer.new())
puts "GT DRB server running"
DRb.thread.join
p "GT DRB server shut down"
